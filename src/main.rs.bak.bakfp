use pnet::datalink::{self, Channel::Ethernet};
use pnet::packet::{
    ethernet::EthernetPacket,
    ipv4::Ipv4Packet,
    tcp::TcpPacket,
    Packet,
};
use std::collections::HashSet;
use std::env;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::net::IpAddr;
use std::process;

fn main() {
    // Parse the command-line arguments to get the network interface
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: {} <network interface>", args[0]);
        process::exit(1);
    }
    let interface_name = &args[1];

    // Find the network interface to use
    let interfaces = datalink::interfaces();
    let interface = interfaces
        .iter()
        .find(|iface| iface.name == *interface_name)
        .unwrap_or_else(|| {
            eprintln!("Error: Network interface {} not found", interface_name);
            process::exit(1);
        });

    // Collect all IP addresses of the local interface
    let local_ips: HashSet<IpAddr> = interface
        .ips
        .iter()
        .map(|ip_network| ip_network.ip())
        .collect();

    // Create a channel to capture packets
    let mut rx = match datalink::channel(interface, Default::default()) {
        Ok(Ethernet(_, rx)) => rx,
        Ok(_) => {
            eprintln!("Unhandled channel type");
            process::exit(1);
        }
        Err(e) => {
            eprintln!("Error creating datalink channel: {}", e);
            process::exit(1);
        }
    };

    // Create a pcap file to log packets
    let mut pcap_file = File::create("packets.pcap").expect("Failed to create pcap file");
    let mut signatures_file =
        BufWriter::new(File::create("muonfp.out").expect("Failed to create muonfp.out file"));

    // Write the PCAP global header
    let pcap_global_header = pcap_file_header();
    pcap_file
        .write_all(&pcap_global_header)
        .expect("Failed to write global header");

    println!("Listening on interface: {}", interface_name);

    // Capture and log packets
    loop {
        match rx.next() {
            Ok(packet) => {
                let ethernet = EthernetPacket::new(packet).unwrap();

                // Write packet to pcap file with pcap packet header
                let pcap_packet_header = pcap_packet_header(ethernet.packet().len() as u32);
                pcap_file
                    .write_all(&pcap_packet_header)
                    .expect("Failed to write packet header");
                pcap_file
                    .write_all(ethernet.packet())
                    .expect("Failed to write packet data");

                if let Some(ip_packet) = Ipv4Packet::new(ethernet.payload()) {
                    let source_ip = IpAddr::V4(ip_packet.get_source());
                    let destination_ip = IpAddr::V4(ip_packet.get_destination());

                    // Skip fingerprinting for packets originating from the local machine
                    if local_ips.contains(&source_ip) {
                        continue;
                    }

                    if let Some(tcp_packet) = TcpPacket::new(ip_packet.payload()) {
                        if tcp_packet.get_flags() & 0x02 != 0 {
                            // Check if SYN flag is set (0x02 is the SYN flag)
                            // Extract TCP window size
                            let window_size = tcp_packet.get_window();

                            // Extract TCP options
                            let options_raw = tcp_packet.get_options_raw();
                            let mut options_str = String::new();
                            let mut mss = None;
                            let mut window_scale = None;

                            let mut i = 0;
                            while i < options_raw.len() {
                                match options_raw[i] {
                                    2 => { // MSS option
                                        if options_raw.len() > i + 3 {
                                            mss = Some(u16::from_be_bytes([
                                                options_raw[i + 2],
                                                options_raw[i + 3],
                                            ]));
                                            options_str.push_str("2-");
                                        }
                                        i += 4; // Length of MSS option
                                    }
                                    3 => { // Window Scale option
                                        if options_raw.len() > i + 2 {
                                            window_scale = Some(options_raw[i + 2]);
                                            options_str.push_str("3-");
                                        }
                                        i += 3; // Length of Window Scale option
                                    }
                                    1 => { // No Operation
                                        i += 1;
                                    }
                                    0 => { // End of Options List
                                        break;
                                    }
                                    _ => {
                                        if options_raw.len() > i + 1 {
                                            i += options_raw[i + 1] as usize;
                                        } else {
                                            break;
                                        }
                                    }
                                }
                            }

                            // Format: source_ip-destination_ip:window_size:option_kinds-mss:window_scale
                            let signature = format!(
                                "{}-{}:{}:{}{}:{}\n",
                                source_ip,
                                destination_ip,
                                window_size,
                                options_str.trim_end_matches('-'),
                                mss.map_or(String::new(), |mss| format!(":{}", mss)),
                                window_scale.map_or(String::new(), |scale| format!("{}", scale)),
                            );

                            // Write signature to file
                            signatures_file
                                .write_all(signature.as_bytes())
                                .expect("Failed to write signature");
                            signatures_file.flush().expect("Failed to flush muonfp.out file");
                        }
                    }
                }
            }
            Err(e) => {
                eprintln!("Failed to read packet: {}", e);
            }
        }
    }
}

// Function to create a PCAP global header
fn pcap_file_header() -> [u8; 24] {
    [
        0xd4, 0xc3, 0xb2, 0xa1, // Magic number
        0x02, 0x00, 0x04, 0x00, // Version major and minor
        0x00, 0x00, 0x00, 0x00, // Thiszone (GMT)
        0x00, 0x00, 0x00, 0x00, // Sigfigs
        0xff, 0xff, 0x00, 0x00, // Snaplen
        0x01, 0x00, 0x00, 0x00, // Network (Ethernet)
    ]
}

// Function to create a PCAP packet header
fn pcap_packet_header(packet_length: u32) -> [u8; 16] {
    let timestamp = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .expect("Time went backwards");
    let secs = timestamp.as_secs() as u32;
    let usecs = timestamp.subsec_micros() as u32;

    [
        (secs & 0xff) as u8,
        ((secs >> 8) & 0xff) as u8,
        ((secs >> 16) & 0xff) as u8,
        ((secs >> 24) & 0xff) as u8,
        (usecs & 0xff) as u8,
        ((usecs >> 8) & 0xff) as u8,
        ((usecs >> 16) & 0xff) as u8,
        ((usecs >> 24) & 0xff) as u8,
        (packet_length & 0xff) as u8,
        ((packet_length >> 8) & 0xff) as u8,
        ((packet_length >> 16) & 0xff) as u8,
        ((packet_length >> 24) & 0xff) as u8,
        (packet_length & 0xff) as u8,
        ((packet_length >> 8) & 0xff) as u8,
        ((packet_length >> 16) & 0xff) as u8,
        ((packet_length >> 24) & 0xff) as u8,
    ]
}
